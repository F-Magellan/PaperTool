// This file has been autogenerated from parsing an Objective-C header file added in Xcode.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Drawing;
using System.Threading;

using MonoTouch.Foundation;
using MonoTouch.UIKit;
using MonoTouch.AVFoundation;
using MonoTouch.CoreVideo;
using MonoTouch.CoreMedia;
using MonoTouch.CoreGraphics;

using MonoTouch.CoreFoundation;
using System.Runtime.InteropServices;
using ZXing;
using ZXing.Common;
using Casascius.Bitcoin;

namespace PaperTool
{
	public partial class DecryptionToolViewController : UIViewController
	{
		public DecryptionToolViewController (IntPtr handle) : base (handle)
		{
		}
		PassphraseKeyPair pairToDecrypt = null;
		string codeToConfirm = null;
		AVCaptureSession session;
		OutputRecorder outputRecorder;
		DispatchQueue queue;

		public void ProcessScannedCode (String code)
		{
			object result = StringInterpreter.Interpret (code, false, 0);
			session.StopRunning ();
			
			if (result == null) {
				lblResult.Text = "Scanned code was not recognized.";
				Application.QRDetails = null;
				btnDetails.Hidden = true;
				SetupCaptureSession ();
			} else if (result is KeyPair) {
				KeyPair kp = result as KeyPair;
				Application.QRDetails = kp.PrivateKey;
				lblResult.Text = "Private key (not encrypted): " + Application.QRDetails +
					"\r\n\r\nAddress: " + kp.AddressBase58;
				Application.QRDetails = kp.AddressBase58;
				Application.decryptionDetails = "You scanned a private key, which can be used for spending funds. This private key " +
					"was not encrypted and did not require a password.";
				btnDetails.Hidden = false;
				SetupCaptureSession ();
				
			} else if (result is AddressBase) {

				lblResult.Text = "You scanned an address.\r\n\r\nAddress:" + (result as AddressBase).AddressBase58;
				Application.QRDetails = (result as AddressBase).AddressBase58;
				Application.decryptionDetails = "You scanned a Bitcoin address.  An address is used for receiving funds, and is " +
					"what you give to someone to request payment.";
				btnDetails.Hidden = false;
				SetupCaptureSession ();
				
			} else if (result is PassphraseKeyPair) {
				if ((Application.currentPassphrase ?? "") == "") {
					lblResult.Text = "This is an encrypted private key, but you have not entered a passphrase to decrypt it.";
					btnDetails.Hidden = false;
					Application.decryptionDetails = "No passphrase has been entered.  Use the Passphrase screen to enter the passphrase that was used to encrypt this private key.";
				} else {
					lblResult.Text = "You scanned an encrypted private key.  Please wait while decrypting.";
					btnDetails.Hidden = true;
					pairToDecrypt = (result as PassphraseKeyPair);
					Thread t = new Thread (new ThreadStart (decryptThreadProc));
					t.Start ();
					activityIndicator.StartAnimating ();
				}
			} else if (result is Bip38Confirmation) {
				lblResult.Text = "You scanned a confirmation code.\r\nPlease wait while decrypting...";
				btnDetails.Hidden = true;
				codeToConfirm = code;
				
				Thread t = new Thread (new ThreadStart (confirmThreadProc));
				t.Start ();
				activityIndicator.StartAnimating ();

			} else {
				lblResult.Text = "This was recognized as a Bitcoin-related code, but this application doesn't know what to do with it.";
				btnDetails.Hidden = true;
				SetupCaptureSession ();

			}
		}

		public override void ViewDidLoad ()
		{
			base.ViewDidLoad ();
			AppDelegate.main.decryptVC = this;
			imageCaptureView.Transform = CGAffineTransform.MakeRotation((float)Math.PI / 2.0f);
		}

		public override void ViewWillAppear (bool animated)
		{
			base.ViewWillAppear (animated);
			SetupCaptureSession();
		}

		public override void ViewWillDisappear (bool animated)
		{
			base.ViewWillDisappear (animated);
			session.StopRunning();
		}

		bool SetupCaptureSession ()
		{
			session = new AVCaptureSession () {
				SessionPreset = AVCaptureSession.PresetMedium
			};
			
			AVCaptureDevice[] capDevices = AVCaptureDevice.DevicesWithMediaType(AVMediaType.Video);

			AVCaptureDeviceInput input = null;
			if (capDevices.Length != 0) input = AVCaptureDeviceInput.FromDevice (capDevices[0]);
			if (input == null){
				new UIAlertView("Error", "Camera not available", null, "OK", null).Show();
				Console.WriteLine ("Camera not available");
				return false;
			}
			session.AddInput (input);
			
			var output = new AVCaptureVideoDataOutput () {
				VideoSettings = new AVVideoSettings (CVPixelFormatType.CV32BGRA),
				MinFrameDuration = new CMTime (1, 30)  //second parameter is frames per second
			};
			
			queue = new MonoTouch.CoreFoundation.DispatchQueue ("myQueue");
			outputRecorder = new OutputRecorder ();
			output.SetSampleBufferDelegateAndQueue (outputRecorder, queue);
			session.AddOutput (output);
			
			session.StartRunning ();
			return true;
		}

		public class OutputRecorder : AVCaptureVideoDataOutputSampleBufferDelegate { 	
			bool barChecking = false;
			UIImage codeImage;
			int numRuns = 0;
			
			public void CheckBarCode ()
			{
				try {
					using(var bbImage = new System.Drawing.Bitmap (codeImage)){
						Reader barReader = new ZXing.QrCode.QRCodeReader();
						//Reader barReader = new MultiFormatReader ();
						LuminanceSource source = new RGBLuminanceSource (bbImage, (int)codeImage.Size.Width, (int)codeImage.Size.Height);
						BinaryBitmap bb = new BinaryBitmap (new HybridBinarizer (source));
						
						Result res = barReader.decode (bb);
						InvokeOnMainThread (() => {
							codeImage.Dispose();
							if (res != null) {
								//result has the string from the image
								//AppDelegate.main.decryptVC.txtScanResult.Text = res.Text;
								AppDelegate.main.decryptVC.ProcessScannedCode(res.Text);
							} else {
								//no valid code found;
							}
							numRuns++;
							barChecking = false;
						});
					}
					
				} catch (Exception e) {
					barChecking = false;
					Console.WriteLine (e);
				}
			}
			
			public override void DidOutputSampleBuffer (AVCaptureOutput captureOutput, CMSampleBuffer sampleBuffer, AVCaptureConnection connection)
			{
				try {
					
					var image = ImageFromSampleBuffer (sampleBuffer);
					sampleBuffer.Dispose();
					captureOutput.Dispose();
					connection.Dispose();
					if (barChecking == false) {
						barChecking = true;
						codeImage = image;
						Thread barCodeThread = new Thread (new ThreadStart (CheckBarCode));
						barCodeThread.Start ();
					}

					AppDelegate.main.decryptVC.imageCaptureView.BeginInvokeOnMainThread (delegate {
						AppDelegate.main.decryptVC.imageCaptureView.Image = image;
					});

				} catch (Exception e) {
					Console.WriteLine (e);
				} 
			}
			
			UIImage ImageFromSampleBuffer (CMSampleBuffer sampleBuffer)
			{
				using (var pixelBuffer = sampleBuffer.GetImageBuffer () as CVPixelBuffer){
					pixelBuffer.Lock (0);
					var baseAddress = pixelBuffer.BaseAddress;
					int bytesPerRow = pixelBuffer.BytesPerRow;
					int width = pixelBuffer.Width;
					int height = pixelBuffer.Height;
					var flags = CGBitmapFlags.PremultipliedFirst | CGBitmapFlags.ByteOrder32Little;
					using (var cs = CGColorSpace.CreateDeviceRGB ()){
						using (var context = new CGBitmapContext (baseAddress,width, height, 8, bytesPerRow, cs, (CGImageAlphaInfo) flags)){
							using (var cgImage = context.ToImage ()){
								pixelBuffer.Unlock (0);
								return UIImage.FromImage (cgImage);
							}
						}
					}
				}
			}
		}

		void decryptThreadProc ()
		{

			PassphraseKeyPair ekp = pairToDecrypt as PassphraseKeyPair;
			if (ekp.DecryptWithPassphrase (Application.currentPassphrase)) {
				InvokeOnMainThread (delegate {
					activityIndicator.StopAnimating();
					string privkey = ekp.GetUnencryptedPrivateKey ().PrivateKey;
					string lnsn = "Batch: (none) Sequence: (none)";
					if (ekp is Bip38KeyPair) {
						Bip38KeyPair ekp38 = ekp as Bip38KeyPair;
						if (ekp38.LotNumber != -1 && ekp38.SequenceNumber != -1) {
							lnsn = "Batch: " + ekp38.LotNumber + " Sequence: " + ekp38.SequenceNumber;
						}
					}

					lblResult.Text = "Decrypted private key: " + privkey +
					"\r\n\r\nAddress: " + ekp.GetAddress().AddressBase58 + "\r\n" + lnsn;
					Application.QRDetails = ekp.GetAddress().AddressBase58;
					btnDetails.Hidden = false;
					Application.decryptionDetails = "You have scanned an unprotected private key which can be used for spending " +
						"from address " + ekp.GetAddress ().AddressBase58 + ".";

				});
				
			} else {

				InvokeOnMainThread (delegate {
					activityIndicator.StopAnimating();
					lblResult.Text = "Incorrect passphrase, could not decrypt.";
					btnDetails.Hidden = false;
					Application.QRDetails = null;
					Application.decryptionDetails = "The passphrase that was entered on the Passphrase screen is not the correct passphrase " +
						"for this spending code.";
				});
			}
			AppDelegate.main.decryptVC.SetupCaptureSession();

		}

		void confirmThreadProc ()
		{
			string message = "Could not decrypt the confirmation code.";
			Application.QRDetails = null;
			try {
				Bip38Confirmation conf = new Bip38Confirmation (codeToConfirm);
				Exception failureReason = conf.DecryptWithPassphrase (Application.currentPassphrase);
				if (failureReason != null) {
					message = failureReason.Message;
				} else {
					message = "It is confirmed that the private spending key for Bitcoin address " + conf.PublicKey.AddressBase58 + " requires your passphrase to " +
						"decrypt.";
					if (conf.LotSequencePresent) {
						message = message + "  Batch " + conf.LotNumber + " Sequence " + conf.SequenceNumber;
					}
					Application.QRDetails = conf.PublicKey.AddressBase58;

					Application.decryptionDetails = "A confirmation code allows you to confirm that a certain Bitcoin address requires " +
						"your passphrase for spending and could not have been generated without it.  Confirmation codes cannot be used " +
							"for spending.";
				}
			} catch {

			}
			InvokeOnMainThread (delegate {
				activityIndicator.StopAnimating ();
				lblResult.Text = message;
				btnDetails.Hidden = false;
			});
		

			AppDelegate.main.decryptVC.SetupCaptureSession();
		}
	}
}

